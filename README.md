# gobi

ðŸ”‘ Core Principles:
One Concept at a Time: Focus on understanding each topic deeply before moving on to the next.

Hands-On Practice: Donâ€™t just read or watch; code every single problem yourself.

Use Node.js: For every problem, write your solution using JavaScript and Node.js. This helps to learn both DSA and JavaScript together.

Time Complexity: Always analyze the time complexity of your solution (i.e., Big-O notation).


âš¡ Week 1-2: Learn JavaScript Basics (for DSA)
Day 1-3: Variables, Data Types, and Functions
Goal: Understand JavaScript syntax, basic data types, and functions.

Topics:

Variables: let, const, var

Data types: String, Number, Boolean, Array, Object, Undefined, Null

Functions: Regular functions, arrow functions, and return values

Loops: for, while, forEach

Action:

Write basic code to manipulate arrays, find max/min elements, reverse strings.

Example problems:

Reverse a string: Write a function to reverse a string.

Find the largest number in an array.

Tools: Use a local JS file in Node.js to practice, or use VSCode.

Practice: Solve basic coding problems on platforms like LeetCode, HackerRank, or CodeSignal.

Day 4-7: Arrays and Strings (Fundamentals)
Goal: Deep dive into Arrays and Strings â€” these are critical for solving most problems.

Topics:

Array manipulation methods: push(), pop(), shift(), unshift(), slice(), splice()

String manipulation methods: substring(), charAt(), concat(), split()

Action:

Write functions to reverse arrays and strings.

Solve problems like:

Given an array, find the sum of all elements.

Check if a string is a palindrome (same backward and forward).

Write a function to find duplicates in an array.

Practice: At least 5 array and string problems daily.


âš¡ Week 3-4: Introduction to Algorithms and Sorting
Day 1-3: Introduction to Algorithms
Goal: Learn how algorithms work and how to analyze them.

Topics:

Big O notation (Time Complexity and Space Complexity)

Types of complexity: Constant O(1), Linear O(n), Logarithmic O(log n), Quadratic O(n^2)

Action:

Write a program to find time complexity for basic operations.

Example:

Write a loop to sum all elements in an array â€” analyze the time complexity.

Practice: Solve 2-3 basic problems where you calculate and discuss time complexity.

Day 4-7: Sorting Algorithms
Goal: Understand basic sorting algorithms and their time complexities.

Topics:

Bubble Sort, Insertion Sort: Simple but inefficient algorithms.

Time Complexity of both: O(n^2)

Action:

Implement Bubble Sort and Insertion Sort in Node.js.

Solve problems like:

Sort an array of numbers using Bubble Sort.

Count inversions in an array using sorting techniques.

Practice: Implement both algorithms and solve at least 5 problems.

âš¡ Week 5-6: Linked Lists
Day 1-3: Introduction to Linked Lists
Goal: Learn how to implement and manipulate linked lists.

Topics:

Singly Linked List: Nodes and linking them using pointers.

Operations: Insert, delete, traverse

Time complexity of linked list operations: O(1) for insertion/deletion at the head, O(n) for insertion/deletion at the tail.

Action:

Create a LinkedList class in Node.js.

Implement basic methods: insertAtHead(), delete(), find().

Practice:

Reverse a linked list.

Find the middle node in a linked list.

Day 4-7: Advanced Linked Lists
Goal: Deepen your understanding of Linked Lists and solve complex problems.

Topics:

Doubly Linked List: Each node has both next and previous pointers.

Circular Linked List: Last node points to the first node.

Action:

Implement Doubly Linked List.

Solve problems like:

Detect a cycle in a linked list.

Remove duplicates in a linked list.

âš¡ Week 7-8: Stacks and Queues
Day 1-3: Stacks
Goal: Understand stacks and their applications.

Topics:

Stack operations: push(), pop(), peek(), isEmpty()

Use case: Undo functionality, expression evaluation

Action:

Implement a Stack using Node.js.

Solve problems like:

Reverse a string using a stack.

Check if parentheses are balanced in an expression.

Practice: Solve at least 5 stack-related problems.

Day 4-7: Queues
Goal: Learn how to implement queues and their use cases.

Topics:

Queue operations: enqueue(), dequeue(), peek(), isEmpty()

Applications: Round-robin scheduling, print job scheduling

Action:

Implement a Queue using Node.js.

Solve problems like:

Implement a Queue using two stacks.

Design a circular queue.

Practice: Solve at least 5 queue-related problems.

âš¡ Week 9-10: Recursion and Backtracking
Day 1-3: Recursion
Goal: Learn recursion, a key concept for many algorithms.

Topics:

Base case and recursive case

Common recursive problems: Factorial, Fibonacci

Action:

Implement recursive solutions for:

Factorial: factorial(n) = n * factorial(n-1)

Fibonacci series using recursion.

Practice: Solve 3 problems using recursion (e.g., sum of numbers, printing subsets).

Day 4-7: Backtracking
Goal: Understand backtracking and its applications.

Topics:

Backtracking concept: Exploring all possible paths to a solution.

Examples: N-Queens problem, Subset Sum Problem

Action:

Solve problems like:

N-Queens problem: Place N queens on a chessboard such that no two queens threaten each other.

Subset Sum: Find subsets of an array whose sum is equal to a given value.

âš¡ Week 11-12: Trees (Binary Trees and Binary Search Trees)
Day 1-3: Binary Trees
Goal: Learn about binary trees and their traversal methods.

Topics:

Types of trees: Full binary tree, complete binary tree

Traversals: Pre-order, In-order, Post-order

Action:

Implement a Binary Tree and its traversals.

Solve problems like:

Height of a binary tree.

Print nodes in level order.

Find the lowest common ancestor of two nodes.

Day 4-7: Binary Search Trees (BST)
Goal: Learn how to implement and manipulate Binary Search Trees.

Topics:

Properties of BSTs: Left < Root < Right

Operations: Insert, Delete, Search

Action:

Implement a Binary Search Tree.

Solve problems like:

Find the minimum and maximum element in a BST.

Inorder traversal of a BST.

âš¡ Week 13-14: Heaps and Hashing
Day 1-3: Heaps
Goal: Learn about Heaps (Min-Heap, Max-Heap) and their applications.

Topics:

Heap Operations: Insert, Remove (Priority Queue)

Time Complexity: O(log n) for insertion/removal

Action:

Implement a Min/Max Heap in Node.js.

Solve problems like:

Find the Kth largest element in an array.

Day 4-7: Hashing
Goal: Understand hash maps and hash sets.

Topics:

Hash functions, collision resolution (chaining, open addressing)

HashMap and HashSet operations

Action:

Implement a HashMap using JavaScript.

Solve problems like:

Two Sum problem using a HashMap.

Group anagrams using a HashMap.

âš¡ Week 15-16: Graphs
Day 1-3: Graph Basics
Goal: Learn the basics of graphs and graph representation.

Topics:

Graph representation: Adjacency Matrix, Adjacency List

Types: Directed, Undirected, Weighted, Unweighted

Action:

Implement a graph using Adjacency List.

Solve basic graph problems like checking if a graph is connected.

Day 4-7: Graph Traversal
Goal: Learn about DFS and BFS.

Topics:

DFS (Depth-First Search) and BFS (Breadth-First Search)

Applications of DFS and BFS

Action:

Implement DFS and BFS in JavaScript.

Solve problems like finding the shortest path in an unweighted graph.

